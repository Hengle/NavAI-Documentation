<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NavAI Documentation: Advanced Settings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NavAI Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('advancedSettings.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Advanced Settings </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="navmesh"></a>
NavMesh</h1>
<div class="image">
<img src="AdvancedMeshSettings.png" alt="AdvancedMeshSettings.png"/>
<div class="caption">
NavMesh Settings Inspector</div></div>
 <h2><a class="anchor" id="hres"></a>
Heightmap Resolution</h2>
<p>Resolution of the NavMesh Heightmap.</p>
<p>The Heightmap is used for baking the navigation mesh and also for height queries, agent height positioning and triangulation rendering.</p>
<p>Higher Heightmap resolutions can result in a higher quality NavMesh baking where the mesh generation process can detect smaller world details with more precision. Increasing the heightmap resolution, however, will greaty increase the time it takes to bake a NavMesh and will also make larger Heightmap files. Heightmap resolution has little no impact on runtime performance other than memory usage.</p>
<h2><a class="anchor" id="tres"></a>
Tilemap Resolution</h2>
<p>Resolution of the Tilemap used for NavMesh baking.</p>
<p>Higher Tilemap resolutions can result in higher quality NavMesh baking, but will significantly slow down the baking process. It is recommended to use lower values for grid based worlds if fast baking is desired. The Tilemap is used exclusively for NavMesh baking and will not affect runtime performance at all.</p>
<h2><a class="anchor" id="mslope"></a>
Max Slope</h2>
<p>Maximum slope angle the agents can walk over.</p>
<p>The maximum slope angle defines which slopes or ramps agents are able to traverse. If a ramp has a slope angle lower than the Max Slope variable, then the agent will be able to walk up that ramp.</p>
<p>Setting this value too high can result in poorly defined obstacles contour, while setting it too low can result in agents not being able to walk up some ramps.</p>
<p>This variable is defined in degrees.</p>
<h2><a class="anchor" id="sheight"></a>
Step Height</h2>
<p>Maximum step height the agents can walk up.</p>
<p>The step height defines which steps the agent can walk up or not. If a stairs have steps which are lower than the Step Height variable, then agents will be able to walk up those stairs.</p>
<p>Setting this value too high can result in agents being able to walk up obstacles that they should not be able to, while setting it too low can result in agents being unable to walk up stairs.</p>
<p>This variable is defined in meters.</p>
<h2><a class="anchor" id="Precision"></a>
Precision</h2>
<p>NavMesh baking precision.</p>
<p>The Precision variable defines how much the polygon decimation process can simplify the obstacles contour during NavMesh Baking.</p>
<p>Larger precision values will generate simpler polygons with less vertices, which also results in triangulations with less triangles, whereas lower precision values will preserve the obstacles contour more.</p>
<p>Setting this value too high can result in poorly defined obstacle contour, while setting it too low can result in obstacles not being simplified enough, giving them a pixelized look.</p>
<p>Precision can affect runtime peformance by reducing or increasing the number of mesh triangles. A NavMesh with more triangles will be slower than a NavMesh with fewer triangles.</p>
<p>It is recommended to use a value that simplifies your polygons just enough to remove excessive vertices and the grid-like aspect of the contour.</p>
<p>This value is defined in meters.</p>
<h2><a class="anchor" id="parea"></a>
Min. Polygon Area</h2>
<p>Minimum polygon area filter for NavMesh baking.</p>
<p>Polygons whose area is smaller than this variable will be completely ignored during the baking process. This includes both areas that are obstructed $($Obstacles$)$ and areas that are not obstructed $($Walkable areas$)$.</p>
<p>Increasing this value can remove undesired noise from the navigation mesh, but setting it too high can cause the baking process to completely ignore some obstacles.</p>
<p>This value is defined in square meters.</p>
<h2><a class="anchor" id="rarea"></a>
Min. Region Area</h2>
<p>Minimum region area filter for NavMesh baking.</p>
<p>Polygons whose area is smaller than this variable and are walkable areas will be completely ignored during the baking process. This will result in these small areas that should be walkable being considered obstacles and unwalkable.</p>
<p>Increasing this value can remove areas that are too small for agents, but setting it too high can result in some areas that should be walkable to be considered obstacles and unwalkable.</p>
<p>This value is defined in square meters.</p>
<h2><a class="anchor" id="mclr"></a>
Min. Clearance</h2>
<p>Minimum area clearance filter for NavMesh baking.</p>
<p>Walkable tiles whose clearance value is smaller than this value will be flagged as obstacles and unwalkable. This will result in thin corridors not being added to the NavMesh as walkable areas.</p>
<p>Setting this value too low can cause the navigation mesh to consider narrow corridors in it's triangulation, whereas setting it too high can remove corridors that should be walkable. This variable has a huge impact on baking performance, and it is recommended to set it to zero for runtime baking if baking speed is important.</p>
<p>It is important to note that even if this value is set to 0, and te triangulation takes corridors that are too narrow, agents whose collision radius are too large for this corridor width will still be unable to traverse it. However, for these cases to work properly, the mesh must have Calculate Clearances set to true.</p>
<p>For editor mesh baking, it is recommended to set this value to the minimum agent size. For runtime baking, it is recommended to set this value to zero.</p>
<p>This value is defined in meters.</p>
<h2><a class="anchor" id="mheight"></a>
Max. Height</h2>
<p>Maximum NavMesh walkable height filter.</p>
<p>Any tile with height greater than this value will be treated as unwalkable.</p>
<p>Setting this value too low can result in some walkable areas be considered not walkable because they are too high.</p>
<p>This value is in meters.</p>
<h2><a class="anchor" id="lmask"></a>
Layer Mask</h2>
<p>Layer Mask filter for NavMesh baking.</p>
<p>Any obstacle whose layer is not in this Layer Mask will be ignored during the baking process.</p>
<p>This layer mask should contain all layers used by obstacles that should be considered by this Navigation Zone.</p>
<h2><a class="anchor" id="zpos"></a>
Zone Position</h2>
<p>The zone world position.</p>
<p>This is the same as the Tranform position.</p>
<p>The zone's volume should contain all of it's obstacles.</p>
<p>This value is in meters.</p>
<h2><a class="anchor" id="zsize"></a>
Zone Size</h2>
<p>The zone world size.</p>
<p>This is not the same as the Transform scale.</p>
<p>The zone's volume should contain all of it's obstacles.</p>
<p>This value is in meters.</p>
<h2><a class="anchor" id="scol"></a>
Scan Colliders</h2>
<p>Toggles scanning all scene Colliders when baking the NavMesh.</p>
<p>This will add a Obstacle Component to any GameObject with a Collider. Note that Agents with collliders will not be considered during this scan.</p>
<h2><a class="anchor" id="smesh"></a>
Scan Meshes</h2>
<p>Toggles scanning all scene Meshes when baking the NavMesh.</p>
<p>This will add a Obstacle Component to any GameObject with a Mesh. Note that Agents with collliders will not be considered during this scan.</p>
<h2><a class="anchor" id="calclr"></a>
Calculate Clearances</h2>
<p>Toggles calculating of triangle clearances.</p>
<p>Triangle clearance is used to tell whether or not a path for an agent can traverse a triangle according to the agent's collision radius.</p>
<p>This process slows down the triangulation process both during NavMesh baking and during NavMesh runtime updates.</p>
<p>It is recommended to turn this feature on if there are narrow corridors on the navigation mesh that larger agents cannot traverse. If all agents can traverse all corridors on the mesh, then this can be turned off for runtime performance gains.</p>
<p>When unsure on how to use this variable, set it to true.</p>
<h2><a class="anchor" id="calh"></a>
Calculate Heights</h2>
<p>Toggles Triangulation Vertex height calculation.</p>
<p>Triangulation Vertex height is used exclusively for NavMesh rendering. It does not have any impact on the physics outcome of the navigation algorithm.</p>
<p>Calculating heights can have some impact on both NavMesh baking and Triangulation runtime updates.</p>
<p>When NavMesh rendering is desired, set this value to true.</p>
<h2><a class="anchor" id="rbak"></a>
Robust Baking</h2>
<p>Toggles robust polygon decimation during NavMesh baking.</p>
<p>By default, polygon decimation will remove any unnecessary vertices from the polygons according to the zone's precision value. This operation, however, can cause polygons to intersect each other. Turning Robust Baking on can prevent this intersection from happening.</p>
<p>Robust Baking is only important if the zone's precision value is too high, which can cause polygon decimation to remove more vertices than it should.</p>
<p>Robust Baking has a huge impact on NavMesh baking, and should be turned off for runtime baking if speed is important.</p>
<p>It is recommended not to use this feature unless NavMesh errors are encountered.</p>
<h2><a class="anchor" id="aagnt"></a>
Arrange Agents</h2>
<p>Toggles parenting Agents under the zone transform.</p>
<h2><a class="anchor" id="aobst"></a>
Arrange Obstacles</h2>
<p>Toggles parenting Obstacles under the zone transform.</p>
<h2><a class="anchor" id="ater"></a>
Arrange Terrains</h2>
<p>Toggles parenting Terrains under the zone transform.</p>
<h2><a class="anchor" id="ebm"></a>
Editor Baking Mode</h2>
<p>Automatic Editor Baking Mode allows the NavigationZone to periodically bake the navmesh to keep it completely updated with the scene. This feature allows the user to continuously make changes to the scene and have the navmesh update automatically to accommodate the changes. This feature only has effect on the editor, while not playing, and if the scene has pending unsaved changes. It is recommended to always click the Generate Mesh button and wait for the bake process to complete before saving the scene to ensure the mesh is baked and saved along with the scene.</p>
<ul>
<li>Automatic: While not in play mode, the NavMesh will automatically bake every few seconds.</li>
<li>Manual: The NavMesh will not bake periodically, and the Generate Mesh button must be used to bake the NavMesh in the editor.</li>
</ul>
<p>Even though most of the mesh baking runs in the background, automatic baking can cause some lag spikes in the editor, and it is recommended to turn it off when experiencing lag problems.</p>
<p>It is important to know that changes made during these updates cannot be undone with the editor Undo operation.</p>
<h2><a class="anchor" id="eidm"></a>
Execute In Edit Mode</h2>
<p>Execute In Edit Mode will run most of the navigation algorithms while not in play mode. This allows the NavMesh to automatically update when dynamic obstacles are added or moved on the editor, and also allows agents to collide with obstacles and other agents.</p>
<ul>
<li>Mesh And Agents: Both NavMesh and Agents will be updated while not in play mode.</li>
<li>Mesh Only: Only the mesh will be updated while not in play mode.</li>
<li>Agents Only: Only the agents will be updated while not in play mode.</li>
<li>None: NavMesh and Agents will be updated while not in play mode.</li>
</ul>
<p>It is important to know that changes made during these updates cannot be undone with the editor Undo operation.</p>
<h2><a class="anchor" id="rev"></a>
Revert To Default</h2>
<p>Reverts all the NavZone settings to the default recommended values. These values may differ depending on the Heightmap Resolution and Tilemap Resolution variables.</p>
<h2><a class="anchor" id="gen"></a>
Generate Mesh</h2>
<p>Starts baking a new NavMesh for this Navigation Zone using the above settings.</p>
<p>Once started, NavMesh baking runs on the background and is automatically saved on the Navigation Zone when the process is complete. Note that this does not save the scene itself, and changes will be lost of the scene is not saved. It is recommended to wait for the bake process to end before saving the scene. </p><hr/>
 <h1><a class="anchor" id="Pathfinding"></a>
Pathfinding</h1>
<div class="image">
<img src="PathfindingSettings.png" alt="PathfindingSettings.png"/>
<div class="caption">
Pathfinding Settings Inspector</div></div>
 <h2><a class="anchor" id="pfThreads"></a>
Pathfinding Threads</h2>
<p>Number of threads to use for pathfinding.</p>
<p>If zero, then all pathfinding will be done on the main thread upon request. This can cause FPS drop if there are too many long paths being calculated every frame. If greater than zero, then all pathfinding will be done using background threads, and pathfinding will not have any impact on the main thread performance.</p>
<p>It is recommended not to use at least two threads for pathfinding.</p>
<h2><a class="anchor" id="pfAbandon"></a>
Abandon Worsening Paths</h2>
<p>If set to true, then agents will automatically abandon their paths when they have not had progress towards the goal for some time.</p>
<p>This is useful when it is desired for agents to stop if their goal is blocked by other agents that are not moving out of the way. However, it is often common for agents to have a hard time finding path progress when they are in a crowded area, and abandoning their paths could lead them to giving up on a path that they would eventually complete.</p>
<h2><a class="anchor" id="pfAbandonTimer"></a>
Abandon timer</h2>
<p>Time in seconds with no progress towards the goal before agents abandon their paths.</p>
<p>Setting this value too low can result in agents abandoning their paths too early when they could eventually complete the path. Setting it too high can cause agents to take too long to give up on paths that cannot be completed.</p>
<h2><a class="anchor" id="pfStopDist"></a>
Occupied Goal Stop Distance</h2>
<p>Distance to stop from goal if the goal is occupied by another agent when stopIfGoalOccupied parameter is set during Agent.SetDestination.</p>
<p>This value is relative to agent radius. An agent of radius 0.50, will stop 0.10 meters away from the goal if this variable is set to 0.20.</p>
<h2><a class="anchor" id="pfFreq"></a>
Path AI Frequency</h2>
<p>Frequency in simulation steps for agents to take Path AI decisions such as abandoning the path or stopping if the goal is occupied.</p>
<p>A frequency of 10 means that the agent will evaluate it's path progress every 10 simulation steps.</p>
<h2><a class="anchor" id="pfgoals"></a>
Search Impossible Goals</h2>
<p>If set to true, pathfinding will search for the nearest reachable goal when the path goal cannot be reached.</p>
<p>A path goal cannot be reached if it is on a different component than the start $($if it is on another island, for example$)$. In this case, if Search Impossible Goals is set to true, the Pathfinder will search for the point on the start component nearest to the desired goal, and the pathfinding will continue with that new goal.</p>
<p>When turned off, if the goal cannot be reached, the pathfinder will fail to find a path and will return an empty path.</p>
<p>This variable does not have a significant impact on pathfinding performance.</p>
<h2><a class="anchor" id="pfClr"></a>
Serch Impossible Clearances</h2>
<p>If set to true, pathfinding will continue searching for paths when the goal could not be reached for clearance reasons.</p>
<p>A goal is unreachable for clearance reasons when the agent cannot traverse a narrow corridor because the agent's collision radius is too large for the corridor clearance.</p>
<p>When set to true, if the goal cannot be reached for clearance reasons, then the Pathfinder will calculate a path up to the corridor that was too narrow and the agent was unable to traverse.</p>
<p>In cases where the path from start to goal is possible, this variable has no impact on pathfinding performance. However, when needed, and if this variable is set to true, the pathfinder will take up to three times as long to find a path.</p>
<h2><a class="anchor" id="pfReqClr"></a>
Required Path Clearance</h2>
<p>This value increases the clearance required for agents to consider a corridor traversable.</p>
<p>Mathematically, an agent of radius 0.60 would be able to traverse a corridor of width 1.20. But with a Required Path Clearance of 1.10, an agent of radius 0.60 would require a corridor with clearance of 1.32 to consider it a valid option for pathfinding.</p>
<h2><a class="anchor" id="pfDefault"></a>
Revert to Default</h2>
<p>Reverts the Pathfinding settings to the default recommended values.</p>
<hr/>
 <h1><a class="anchor" id="collisionAvoidance"></a>
Collision Avoidance</h1>
<div class="image">
<img src="CollisionAvoidanceSettings.png" alt="CollisionAvoidanceSettings.png"/>
<div class="caption">
Collision Avoidance Settings Inspector</div></div>
 <h2><a class="anchor" id="rvoUpdate"></a>
Update Mode</h2>
<ul>
<li>Every Frame: The Navigation Zone will run a simulation step every frame update.</li>
<li>Every Fixed Frame: The Navigation Zone will run a simulation step every fixed frame update.</li>
</ul>
<p>Since movement is physics related, and physics is usually calculated inside the fixed frame update, it is recommended to use Every Fixed Frame option for the Update Mode.</p>
<p>It is important to note that the simulation time step will adjust to the selected update mode.</p>
<h2><a class="anchor" id="rvoThreads"></a>
RVO Threads</h2>
<p>Number of threads to use for collision avoidance.</p>
<p>Even though all collision avoidance is done within the main thread scope, having more than 1 threads working on collision avoidance can significantly increase the collision avoidance performance on the main thread, as the work will be spread across multiple threads.</p>
<p>On zones where there will be more than 20 agents at any given time, it is recommended to use more than one thread for collision avoidance.</p>
<h2><a class="anchor" id="rvoTime"></a>
RVO Time Horizon</h2>
<p>Time horizon in seconds for agents to detect and start avoiding future. collisions.</p>
<p>Higher values allows agents to start avoiding collisions that are further away, whereas lower values will cause agents to start avoiding collisions only when they are nearly happening.</p>
<p>If set to nearly or exactly zero, then agents will only avoid collisions a moment before it happens.</p>
<h2><a class="anchor" id="rvoLowSpeed"></a>
Low Speed Percentage</h2>
<p>Speed percentage at which agents are considered to be under-performing their movement capabilities.</p>
<p>The speed percentage for an agent equals it's currentSpeed divided by it's movementSpeed. An agent of movementSpeed 2.0 and currentSpeed 1.0 has a current speed percentage of 0.50.</p>
<p>Agents that are under-performing are candidates for being considered stuck. Agents considered stuck receive an internal movement priority that allows them to get unstuck. This is particularly useful on crowded narrow corridors along with the Unstuck Priority variable set to true.</p>
<p>Agents whose speed percentage stay below this value for long enough are considered stuck.</p>
<p>Setting this value too high will cause agents to be considered stuck when they are not actually stuck. Setting it too low can cause agents to never be considered stuck.</p>
<p>It is recommended to set this value around 0.05 $(5%)$. In case agents get stuck for too long, increasing this value can sometimes solve the situation.</p>
<h2><a class="anchor" id="rvoHighSpeed"></a>
High Speed Percentage</h2>
<p>Speed percentage at which agents are considered to be performing their movement capabilities well enough.</p>
<p>The speed percentage for an agent equals it's currentSpeed divided by it's movementSpeed. An agent of movementSpeed 2.0 and currentSpeed 1.0 has a current speed percentage of 0.50.</p>
<p>Agents that are under-performing are candidates for being considered stuck. Agents considered stuck receive an internal movement priority that allows them to get unstuck. This is particularly useful on crowded narrow corridors along with the Unstuck Priority variable set to true.</p>
<p>Agents whose speed percentage stay above this value for long enough are not considered stuck.</p>
<p>Setting this value too high will cause agents to be considered stuck when they are not actually stuck. Setting it too low can cause agents to never be considered stuck.</p>
<p>It is recommended to set this value around 0.50 $(50%)$. In case agents get stuck for too long, increasing this value can sometimes solve the situation.</p>
<h2><a class="anchor" id="rvoZeroSpeed"></a>
Zero Speed Percentage</h2>
<p>Speed percentage at which agents are considered to not be currently moving.</p>
<p>Agents are not likely to have their speed at exactly zero. Instead, it will be nearly zero. This percentage value allows to considered speeds that are too low to equal zero.</p>
<p>An agent that has zero speed is a candidate for different collision avoidance approaches than agents that are moving.</p>
<p>Setting this value too low can cause these different collision avoidance approaches to never trigger, whereas setting ti too high can cause these approaches to trigger on the wrong situations. An example of such different collision avoidance approach is the Avoid Unmoving Agents, which is responsible for a group of agents being able to completely surround another agent.</p>
<p>It is recommended to set this value to 0.01 $(1%)$. In case agents are not being able to avoid collisions with agents that seem to not be moving, increasing this value can sometimes solve the situation.</p>
<h2><a class="anchor" id="rvoLowSpeedTime"></a>
Low Speed Time</h2>
<p>Time in seconds for agents to be considered stuck when under-performing.</p>
<p>If an agent has been under-performing it's movement capabilities for this long, then it will be considered stuck and will be a candidate for anti-stuck routines.</p>
<p>It is recommended to set this value around one second. Increasing the value can cause agents to take too long to be considered stuck. Decreasing it can cause agents to be considered stuck too early.</p>
<h2><a class="anchor" id="rvoHighSpeedTime"></a>
High Speed Time</h2>
<p>Time in seconds for agents to no longer be considered stuck after performing their movement capabilities well enough.</p>
<p>If an agent has been above High Speed Percentage for this long, it will not be considered stuck and will no longer be a candidate for anti-stuck routines.</p>
<p>It is recommended to set this value around five seconds. Increasing the value can cause agents to be considered stuck for too long. Decreasing it can cause agents to not be considered stuck for long enough for them to get unstuck.</p>
<h2><a class="anchor" id="rvoPriority"></a>
Enable Priority</h2>
<p>Toggles collision avoidance priority during collision avoidance calculation.</p>
<p>Each agent can have a collision avoidance priority variable assigned to it. Enabling this variable allows the agents to use their collision avoidance priority during collision avoidance calculations, and also allows the internal algorithms to assign priority to agents as needed to get agents unstuck.</p>
<p>When calculating collisions, the agent with higher priority will move in a straight line while the agent with lower priority will be responsible for all the collision avoidance. If both agents have the same collision avoidance priority, then each will take half of the collision avoidance responsibility.</p>
<p>If disabled, then the collision avoidance priority assigned to agents will have no effect whatsoever.</p>
<h2><a class="anchor" id="rvoUnstuck"></a>
Unstuck Priority</h2>
<p>Toggles assigning internal high priority values to agents that are stuck to get them unstuck.</p>
<p>If enabled, agents that are considered stuck will have collision avoidance priority over agents that are not considered stuck.</p>
<h2><a class="anchor" id="rvoIdle"></a>
Idle Priority</h2>
<p>Toggles assigning internal low priority values to agents that are Idle.</p>
<p>If enabled, agents that are Idle will have a lower collision avoidance priority than other agents that are not Idle.</p>
<p>This rule only applies to agents with friendly team relationship.</p>
<h2><a class="anchor" id="rvoRange"></a>
Priority Detection Range</h2>
<p>Priority detection distance relative to the agent radius.</p>
<p>The detection distance in meters is calculated by multiplying the combined radius of the two agents avoiding collision with one another by this variable. An agent of collision radius 0.50 avoiding collision with another agent of collision radius 0.60 will have a combined radius of 1.10 and a priority detection range of 1.65 meters when this variable is set to 1.50.</p>
<p>Agents will only start using priority rules with another agent when within this distance of it.</p>
<p>This value should never be less than one.</p>
<h2><a class="anchor" id="rvoSpacing"></a>
Priority Spacing Percentage</h2>
<p>Agent spacing relative to agent radius to maintain when priority rules are being applied.</p>
<p>The spacing in meters is calculated by multiplying the combined radius of the two agents avoiding collisions with one another by this variable. An agent of collision radius 0.50 avoiding collision with another agent of collision radius 0.60 will have a combined radius of 1.10 and a priority spacing of 1.21 meters when this variable is set to 1.10.</p>
<p>This value should never be less than one.</p>
<h2><a class="anchor" id="Priority"></a>
Propagation Depth</h2>
<p>Maximum recursion depth for internal priority propagation.</p>
<p>This value will prevent performance problems when there are too many agents grouped up. The default value is 20. Increasing it can increase the quality of the unstuck algorithm, but can also affect performance on the main thread.</p>
<p>If Unstuck Priority is set to false, then this variable will have no effect.</p>
<h2><a class="anchor" id="rvoUnmoving"></a>
Avoid Unmoving Agents</h2>
<p>Enables the use of different collision avoidance algorithms to deal with agents that are not moving.</p>
<p>These algorithms are responsible for the Agent Surround Behavior, which allows group of agents to completely surround another agent, or for the agent to get away from that same situation.</p>
<p>Turning this off can improve performance in some cases.</p>
<h2><a class="anchor" id="rvoUnmovingduration"></a>
Unmoving Avoidance Duration</h2>
<p>Time in seconds for agents to forget their previous unmoving behavior when not using it.</p>
<p>Internally, the unmoving behavior gives each agent a direction to follow $($left or right$)$. Forgetting the unmoving behavior, means that the agent will discard it's current direction and get a new one.</p>
<p>Recommended value is five seconds. Increasing this value can help agents overcome some situations, but will not allow them to quickly reset behavior for new situations. Decreasing this values can cause agents to forget their direction too often and make it impossible for them to solve some situations.</p>
<h2><a class="anchor" id="rvoDefault"></a>
Revert to Default</h2>
<p>Reverts all collision avoidance settings to the default recommended settings. </p><hr/>
 <h1><a class="anchor" id="Agent"></a>
Agent</h1>
<div class="image">
<img src="AgentSettings.png" alt="AgentSettings.png"/>
<div class="caption">
Agent Settings Inspector</div></div>
 <h2><a class="anchor" id="aMaxSpeed"></a>
Max. Agent Speed</h2>
<p>Maximum allowed agent movement speed in meters per second.</p>
<p>This value is used internally to know how far to search for agent neighbors when calculating collision avoidance.</p>
<p>While using agents with movement speed higher than this in the scene would not be critical to the application, it could cause collision avoidance to ignore agents that are moving faster than this.</p>
<p>Setting this value too high can result in larger neighbor search radius, which makes collision avoidance calculation slower. It is recommended to globally define a maximum agent movement speed for the game and put this value here.</p>
<h2><a class="anchor" id="aMaxRadius"></a>
Max. Agent Radius</h2>
<p>Maximum allowed agent radius in meters.</p>
<p>This value is used internally to know how far to search for agent neighbors when calculating collision avoidance.</p>
<p>While using agents with collision radius larger than this in the scene would not be critical to the application, it could cause collision avoidance to ignore agents that are moving too fast.</p>
<p>Setting this value too high can result in larger neighbor search radius, which makes collision avoidance calculation slower. It is recommended to globally define a maximum agent collision radius for the game and put this value here.</p>
<h2><a class="anchor" id="aIdle"></a>
Return to Idle Position</h2>
<p>Toggles agents automatically returnin to their Idle position when they get pushed away from it.</p>
<p>Idle agents can get pushed away from their position due to collision avoidance. Enabling Return to Idle Position makes them return to their original Idle position when they become too far away from it.</p>
<h2><a class="anchor" id="aIdleDist"></a>
Idle Position Distance</h2>
<p>When Return to Idle Position is enabled, this will be the distance in meters from the original Idle position for agents to start returning to their original Idle position.</p>
<h2><a class="anchor" id="aMaxAng"></a>
Max Angular Acceleration</h2>
<p>Angular acceleration used for agent rotation in radians per seconds squared.</p>
<p>Each agent rotation speed is limited by their rotationSpeed variable, but they will not accelerate their rotation speed more than this.</p>
<p>Lower values will make the agents orientation more stable. If set to zero, then agents will have infinite acceleration and agents will always rotate using their rotationSpeed variable.</p>
<h2><a class="anchor" id="aStab"></a>
Rotation Stability</h2>
<p>Quality of agents rotation stability.</p>
<p>Collisions can often cause agents to rotate too much. This variable offers rotation stability in a way that agents will use their average velocity over the last steps to calculate their current orientation.</p>
<p>Higher values can make agents seem like they are sliding sideways instead of moving forward. Lower values can make agents rotate too much in crowded environments. If set to None, then agents will use their current velocity as their current orientation.</p>
<h2><a class="anchor" id="aDefault"></a>
Revert to Default</h2>
<p>Reverts the Agent settings to the default recommended settings. </p><hr/>
 <h1><a class="anchor" id="Rendering"></a>
Rendering</h1>
<div class="image">
<img src="RenderingSettings.png" alt="RenderingSettings.png"/>
<div class="caption">
Rendering Settings Inspector</div></div>
 <h2><a class="anchor" id="rMesh"></a>
Mesh Rendering</h2>
<ul>
<li>Always Render: NavMesh will always be rendered.</li>
<li>Render If Not Playing: NavMesh will only render in the editor while not in play-mode and will not render outside the editor.</li>
<li>Render If Playing: NavMesh will only play in the editor if in play-mode and will always render outside the editor.</li>
<li>Render If Selected: NavMesh will only render in the editor if it is selected and will never render outside the editor.</li>
<li>Never Render: NavMesh will not be rendered.</li>
</ul>
<h2><a class="anchor" id="rDraw"></a>
Mesh Draw Mode</h2>
<ul>
<li>Shaded: Triangles interior will be rendered.</li>
<li>Wireframe: Triangles interior will not be rendered.</li>
</ul>
<h2><a class="anchor" id="rMeshColorMesh"></a>
Color</h2>
<p>Material color for rendering the NavMesh.</p>
<h2><a class="anchor" id="rMeshHeight"></a>
Mesh Draw Height</h2>
<p>NavMesh vertices height offset in meters.</p>
<p>Default value is 0.10. Increasing this value can cause your triangles to float above the surface. Decreasing it can cause some vertices to hide under the surface.</p>
<h2><a class="anchor" id="rAgentRender"></a>
Agent Rendering</h2>
<ul>
<li>Always Render: Agents will always be rendered.</li>
<li>Render If Not Playing: Agents will only render in the editor while not in play-mode and will not render outside the editor.</li>
<li>Render If Playing: Agents will only play in the editor if in play-mode and will always render outside the editor.</li>
<li>Render If Selected: Agents will only render in the editor if it is selected and will never render outside the editor.</li>
<li>Never Render: Agents will not be rendered.</li>
</ul>
<h2><a class="anchor" id="rAgentDraw"></a>
Agent Draw Mode</h2>
<ul>
<li>Circle Only: Only the agents collision radius will be drawn.</li>
<li>Circle And Arrow: Both the agents collision radius and orientation will be drawn.</li>
</ul>
<h2><a class="anchor" id="rAgentColor"></a>
Agent Color</h2>
<p>Material color for rendering agents.</p>
<h2><a class="anchor" id="rAgentHeight"></a>
Agent Draw Height</h2>
<p>Agent draw height offset in meters.</p>
<p>Default value is 0.10. Increasing this value can cause the agent drawings to float above the surface. Decreasing it can cause some vertices to hide under the surface.</p>
<h2><a class="anchor" id="rPath"></a>
Draw Paths</h2>
<p>Toggles drawing paths for agents that are being drawn.</p>
<h2><a class="anchor" id="rPathColor"></a>
Path Color</h2>
<p>Material color for rendering paths. </p><hr/>
 <h1><a class="anchor" id="Debug"></a>
Debug</h1>
<div class="image">
<img src="DebugSettings.png" alt="DebugSettings.png"/>
<div class="caption">
Debug Settings Inspector</div></div>
 <h2><a class="anchor" id="dMode"></a>
Debug Mode</h2>
<p>Toggles the display of debug messages.</p>
<h2><a class="anchor" id="dLog"></a>
Log Messages</h2>
<p>Toggles the display of informative messages.</p>
<h2><a class="anchor" id="dWarning"></a>
Log Warnings</h2>
<p>Toggles the display of important warning messages.</p>
<h2><a class="anchor" id="dError"></a>
Log Errors</h2>
<p>Toggles the display of critical error messages.</p>
<h2><a class="anchor" id="dDefault"></a>
Revert to Default</h2>
<p>Reverts the Debug settings to the default recommended values. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
